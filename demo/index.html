<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>ImgPack Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 20px; }
    #wrap { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
    canvas { image-rendering: pixelated; border: 1px solid #ccc; }
    pre { background: #f9fafb; border: 1px solid #eee; margin:0; padding: 8px; border-radius: 6px; max-height: 50vh; overflow: auto; }
    label { margin-right: 6px; }
    input, select, button { padding: 6px 8px; margin-right: 10px; }
  </style>
</head>
<body>
  <h1>ImgPack Demo</h1>
  <div>Status: <span id="status">connectingâ€¦</span></div>

  <div style="margin-bottom: 2em;">
    <label>dtype:</label>
    <select id="dtype">
      <option>uint8</option>
      <option selected>uint16</option>
      <option>uint32</option>
      <option>float16</option>
      <option>float32</option>
      <option>float64</option>
      <option>packed</option>
    </select>

    <label>bits:</label>
    <input id="bits" type="number" value="12" min="1" max="32" />
    <button id="apply">Apply mode</button>
    <button id="reload">Reload frame</button>
  </div>

  <div id="wrap">
    <canvas id="cv" width="10" height="10"></canvas>
    <pre id="meta"></pre>
  </div>

  <script type="module">
    import { decode } from "/decode.js";

    const statusEl = document.getElementById("status");
    const meta = document.getElementById("meta");
    const canvas = document.getElementById("cv");
    const dtypeSel = document.getElementById("dtype");
    const bitsInp = document.getElementById("bits");
    const applyBtn = document.getElementById("apply");
    const reloadBtn = document.getElementById("reload");

    const ws = new WebSocket((location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws");
    ws.binaryType = "arraybuffer";

    ws.onopen = () => { statusEl.textContent = "connected"; ws.send("send") };
    ws.onerror = (e) => { statusEl.textContent = "error"; console.error(e); };
    ws.onclose = () => { statusEl.textContent = "closed"; };

    ws.onmessage = async (evt) => {
      const ab = (evt.data instanceof Blob) ? await evt.data.arrayBuffer() : evt.data;
      try {
        const { header, typed } = decode(ab);
        meta.textContent = JSON.stringify(header, null, 2);
        renderGrayscale(canvas, typed, header);
      } catch (e) {
        meta.textContent = "Decode error: " + e.message;
        console.error(e);
      }
    };

    applyBtn.onclick = async () => {
      const dtype = dtypeSel.value;
      const bits = parseInt(bitsInp.value, 10);
      await fetch("/set_mode", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ dtype, bits })
      });
      if (ws.readyState === WebSocket.OPEN) ws.send("send");
    };

    reloadBtn.onclick = () => {
      if (ws.readyState === WebSocket.OPEN) ws.send("send");
    };

    function renderGrayscale(canvas, typed, header) {
      const [H, W] = header.shape;
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext("2d");
      const img = ctx.createImageData(W, H);
      const px = img.data;

      const dtype = header.dtype.toLowerCase();

      if (dtype.startsWith("float")) {
        // Normalize using vmin/vmax if provided
        const vmin = Number.isFinite(header.vmin) ? header.vmin : Math.min(...typed);
        const vmax = Number.isFinite(header.vmax) ? header.vmax : Math.max(...typed);
        const scale = vmax > vmin ? 255 / (vmax - vmin) : 1;
        for (let i = 0, j = 0; i < typed.length; i++, j += 4) {
          const g = Math.max(0, Math.min(255, ((typed[i] - vmin) * scale) | 0));
          px[j] = g; px[j+1] = g; px[j+2] = g; px[j+3] = 255;
        }
      } else {
        // Integers: use resolution if available
        let res = header.resolution;
        if (!res) {
          // If dtype is uint8/16/32 but resolution is missing, infer full-range
          res = (dtype === "uint8") ? 256 : (dtype === "uint16" ? 65536 : 4294967296);
        }
        const scale = 255 / (res - 1);
        for (let i = 0, j = 0; i < typed.length; i++, j += 4) {
          const g = Math.max(0, Math.min(255, (typed[i] * scale) | 0));
          px[j] = g; px[j+1] = g; px[j+2] = g; px[j+3] = 255;
        }
      }
      ctx.putImageData(img, 0, 0);
    }
  </script>
</body>
</html>
